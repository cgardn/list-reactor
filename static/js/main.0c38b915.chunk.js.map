{"version":3,"sources":["Editlabel.js","Listitem.js","Todolist.js","Todoboard.js","App.js","serviceWorker.js","index.js"],"names":["Editlabel","props","isEdit","onSubmit","event","preventDefault","setIsEdit","onDragStart","draggable","className","value","content","autoFocus","onFocus","target","select","onChange","id","onBlur","stopPropagation","onClick","Itemmenu","style","top","posY","left","posX","Listitem","React","useState","contextMenu","setContextMenu","DeleteButton","useContext","ItemDispatchContext","pageX","pageY","String","fromCharCode","Container","key","draggableId","toString","index","parseInt","provided","ref","innerRef","draggableProps","dragHandleProps","children","onDeleteClick","Todolist","listDispatch","ListDispatchContext","itemDispatch","isTitleEdit","setTitleEdit","changeItem","newContent","type","payload","handleAdditemClick","listId","itemId","getId","itemIndex","isPlaceholder","changeListTitle","handleSwapItems","console","log","renderedItems","ownedItems","map","item","allItems","swapItems","dragDispatch","thisClass","Title","title","canDelete","List","droppableId","droppableProps","placeholder","AddButton","fontsize","listReducer","state","action","filter","list","items","includes","insertIndex","length","isNaN","slice","concat","movedItem","sourceList","splice","sourceIndex","destList","destIndex","dragId","swapId","sortedIndexes","indexOf","sort","obj","itemReducer","draggedIndex","draggedId","hoverIndex","hoverId","dragReducer","createContext","initialListState","initialItemState","initialDragState","Todoboard","useReducer","lists","draggedItem","startId","nextItemId","setNextItemId","outId","addList","nl","removeList","forEach","getListSize","AddListButton","ListContainer","onDragEnd","source","destination","Provider","getSize","canEditTitle","width","App","Component","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.0c38b915.chunk.js","sourcesContent":["import React from 'react';\n\nconst Editlabel = (props) => {\n  // Editable label, a span that replaces itself with an Input box+form on click\n  // props:\n  //  id: integer, unique to the app state for manipulating \n  //      the label inside state object\n  //  content: string, displayed text on the label\n  //  class: for setting className (CSS styles)\n  //  isEdit: bool, true if in editable input state, false if\n  //          plain text span\n  //  setIsEdit: function ref for setting isEdit on parent\n  //  onChange: function ref for controlling input on parent\n  //            state\n\n  const preventDrag = (event) => {\n    event.preventDefault();\n    event.stopPropagation();\n  };\n\n  return (\n    <>\n    {props.isEdit === true\n      ? <form \n          onSubmit={event => {\n            event.preventDefault()\n            props.setIsEdit(false)}\n          }\n          onDragStart={event => {\n            return false\n          }}\n          draggable={false}\n        >\n          <input\n            draggable={false}\n            className={props.className}\n            value={props.content}\n            autoFocus={true}\n            onFocus={event => event.target.select()}\n            onChange={event => props.onChange(props.id, event.target.value)}\n            onBlur={event => props.setIsEdit(false)}\n            onDragStart={preventDrag}\n          >\n          </input>\n        </form>\n      : <span \n          className={props.className}\n          onClick={event => props.setIsEdit(true)}\n        >{props.content}</span>\n    }\n    </>\n  );\n};\n\nexport default Editlabel;\n","import React from 'react'\nimport Editlabel from './Editlabel';\nimport {Draggable} from 'react-beautiful-dnd';\n\nimport {ItemDispatchContext} from './Todoboard';\n\n// A single todo item. Editable (with Editlabel), and draggable, onto any <Todolist /> \n//\n// props:\n//  id: integer, unique on the page, for manipulating in\n//        top-level state\n//  content: string, the text content of the todo, passed down\n//            from top-level state\n//  onChange: function ref, passed down to child Editlabel for\n//            controlling the input when editing content\n//  onDeleteClick: function ref, passed from parent Todolist,\n//      for deleting this todo from top-level state\n\nconst Itemmenu = (props) => {\n  return (\n    <button\n      className=\"item-menu\"\n      autoFocus={true}\n      style={{ top: props.posY, left: props.posX }}\n      onClick={props.onClick}\n      onBlur={props.onBlur}\n    >Delete</button>\n  );\n};\n\nconst Listitem = (props) => {\n  // State hooks\n  const [contextMenu, setContextMenu] = React.useState([0,0,false]);\n  const [isEdit, setIsEdit] = React.useState(false);\n\n  // Context consumers\n  const itemDispatch = React.useContext(ItemDispatchContext);\n\n  const handleDragStart = (event) => {\n    itemDispatch({\n      type: 'SET_IS_PLACEHOLDER',\n      payload: {\n        itemId: props.id,\n        isPlaceholder: true}\n    });\n    props.dragDispatch({\n      type: 'SET_DRAGGED_ITEM',\n      payload: {item: props.id, index: props.index},\n    });\n  };\n\n  const handleDragEnter = (event) => {\n    event.stopPropagation();\n    if (props.isPlaceholder) return;\n    console.log(\"entered\");\n  };\n\n  const DeleteButton = () => {\n    return (\n        <button\n          className=\"deleteItemButton list-item-objects\"\n          onClick={event => setContextMenu([event.pageX, event.pageY, !contextMenu[2]])}\n        >\n        {String.fromCharCode(9899) + ' ' + String.fromCharCode(9899) + ' ' + String.fromCharCode(9899)}\n        </button>\n    );\n  };\n\n  const Container = (props) => {\n    return (\n      <Draggable \n        key={props.id}\n        draggableId={props.id.toString()} \n        index={parseInt(props.index)}\n      >\n        {(provided) => (\n          <div \n            className=\"list-item\" \n            ref={provided.innerRef}\n            {...provided.draggableProps}\n            {...provided.dragHandleProps}\n          >\n            {props.children}\n          </div>\n        )}\n      </Draggable>\n    );\n  };\n\n  return (\n      <Container id={props.id} index={parseInt(props.index)}>\n        <Editlabel\n          className={\"list-item-objects list-item-label\"}\n          id={props.id}\n          content={props.content}\n          onChange={props.onChange}\n          isEdit={isEdit}\n          setIsEdit={setIsEdit}\n        />\n        <DeleteButton />\n        {contextMenu[2] && \n          <Itemmenu\n            posX={contextMenu[0]}\n            posY={contextMenu[1]}\n            onClick={props.onDeleteClick}\n          onBlur={event => setContextMenu([0,0,!contextMenu])}\n          />\n        }\n      </Container>\n  );\n};\n\nexport default Listitem;\n","import React from 'react';\nimport Editlabel from './Editlabel';\nimport Listitem from './Listitem';\nimport {ListDispatchContext, ItemDispatchContext} from './Todoboard.js';\nimport { Droppable } from 'react-beautiful-dnd';\n\nconst Todolist = (props) => {\n  const listDispatch = React.useContext(ListDispatchContext);\n  const itemDispatch = React.useContext(ItemDispatchContext);\n  const [isTitleEdit, setTitleEdit] = React.useState(false);\n\n  const handleDragEnter = (event) => {\n    listDispatch({\n      type: 'INSERT_TODO',\n      payload: {\n        listId: props.id,\n        itemId: props.draggedItem.item,\n        insertIndex: -1\n      }\n    });\n    if (props.draggedItem.list !== props.id) {\n      listDispatch({\n        type: 'REMOVE_TODO',\n        payload: {\n          listId: props.draggedItem.list,\n          itemId: props.draggedItem.item,\n        },\n      });\n    }\n    props.dragDispatch({\n      type: 'UPDATE_HOVERED_LIST',\n      payload: props.id,\n    });\n  };\n\n  const handleDragOver = (event) => {\n    event.preventDefault();\n  };\n\n  const changeItem = (id, newContent) => {\n    itemDispatch({\n      type: 'UPDATE_TODO_CONTENT',\n      payload: {id: id, content: newContent}\n    });\n  };\n\n  const removeItem = (id) => {\n    itemDispatch({\n      type: 'REMOVE_TODO',\n      payload: {\n        listId: props.id,\n        itemId: id,\n      },\n    });\n    listDispatch({\n      type: 'REMOVE_TODO',\n      payload: {\n        listId: props.id,\n        itemId: id,\n      },\n    });\n  };\n\n  const handleAdditemClick = () => {\n    listDispatch({\n      type: 'INSERT_TODO',\n      payload: {\n        listId: props.id,\n        itemId: props.getId(),\n        itemIndex: -1,\n      }\n    });\n    itemDispatch({\n      type: 'ADD_TODO',\n      payload: {\n        id: props.getId(),\n        content: \"Click to edit\",\n        isPlaceholder: false}\n    });\n  };\n\n  const changeListTitle = (id, content) => {\n    listDispatch({\n      type: 'UPDATE_LIST_TITLE',\n      id: id,\n      payload: content\n    });\n  };\n\n  const handleSwapItems = (event) => {\n    console.log(\"swap items\");\n  };\n\n  const renderedItems = (\n    props.ownedItems.map( (item, index) => (\n          <Listitem\n            key={props.allItems[item].id}\n            id={props.allItems[item].id}\n            index={index}\n            content={props.allItems[item].content}\n            isPlaceholder={props.allItems[item].isPlaceholder}\n            swapItems={handleSwapItems}\n            dragDispatch={props.dragDispatch}\n            onChange={changeItem}\n            onDeleteClick={() => removeItem(item)}\n          />\n    ))\n  );\n\n  const handleMouseDown = (event) => {\n    console.log(\"X, Y\", event.pageX, event.pageY);\n    console.log(event.currentTarget);\n    console.log(event);\n  };\n\n  const handleTouchStart = (event) => {\n    console.log(event);\n  };\n\n  const Container = (props) => {\n    return (\n      <div className={`${props.thisClass}-individual`}>\n        {props.children}\n      </div>\n    );\n  };\n\n  const Title = () => {\n    return (\n      <div className={`${props.thisClass}-individual-title`}>\n        <Editlabel\n          className={\"list-item-objects list-item-label\"}\n          id={props.id}\n          content={props.title}\n          onChange={changeListTitle}\n          isEdit={isTitleEdit}\n          setIsEdit={setTitleEdit}\n        />\n      {props.canDelete &&\n        <button\n          className=\"list-delete-button\"\n          onClick={props.onDeleteClick}\n        >X</button>\n      }\n      </div>\n    );\n  };\n\n  const List = () => {\n    \n    return (\n      <Droppable droppableId={props.id}>\n        { (provided) => (\n          <div \n            ref={provided.innerRef} \n            {...provided.droppableProps}\n            className={`${props.thisClass}-list`}\n          >\n            {renderedItems}\n            {provided.placeholder}\n          </div>\n        )}\n      </Droppable>\n    );\n  };\n\n  const AddButton = () => {\n    return (\n      <button\n        className={\"addItemButton\"}\n        style={{ fontsize: '2rem' }}\n        onClick={handleAdditemClick}\n      >{\"+\"}</button>\n    );\n  };\n\n  return (\n    <Container thisClass={props.thisClass}>\n      <Title />\n      <List />\n      <AddButton />\n    </Container>\n  );\n};\n\nexport default Todolist;\n","import React from 'react';\nimport Todolist from './Todolist';\nimport {DragDropContext} from 'react-beautiful-dnd';\nimport './Todoboard.css';\n\nconst listReducer = (state, action) => {\n  switch(action.type) {\n    case 'ADD_LIST':\n      return [ ...state, action.payload ];\n    case 'REMOVE_LIST':\n      return state.filter(list => list.id !== action.listId);\n    case 'UPDATE_LIST_TITLE':\n      return state.map( list => {\n        if (list.id === action.id) {\n          return { ...list, title: action.payload};\n        } else {\n          return list\n        }\n      });\n    case 'INSERT_TODO':\n      // payload: \n      //  - listId: id of list item goes into\n      //  - itemId: id of item being inserted\n      //  - insertIndex: index to insert item at, or -1 to append\n      return state.map( list => {\n        if (list.id === action.payload.listId) {\n          // return if item already in list, prevents adding\n          // multiple times when moving around inside list\n          if (list.items.includes(action.payload.itemId)) {\n            return list;\n          }\n          let insertIndex = (action.payload.itemIndex === -1 ? list.items.length : action.payload.itemIndex)\n          // bandaid to fix insertIndex arriving as undefined\n          if (isNaN(insertIndex)) insertIndex = list.items.length;\n          return {...list, items: list.items.slice(0,insertIndex).concat(action.payload.itemId).concat(list.items.slice(insertIndex, list.items.length))}\n        } else {\n          return list\n        }\n      });\n    case 'MOVE_TODO':\n      let movedItem = state.filter( list => list.id === action.payload.sourceList)[0].items.splice(action.payload.sourceIndex,1);\n      return state.map( list => {\n        if (list.id === action.payload.destList) {\n          return {\n            ...list,\n            items: list.items.slice(0,action.payload.destIndex).concat(movedItem).concat(list.items.slice(action.payload.destIndex, list.items.length)),\n          }\n        } else {\n          return list\n        }\n      })\n    case 'SWAP_TODOS':\n      // payload:\n      //  - dragId: id of currently held dragitem\n      //  - swapId: id of item being swapped with\n      //  - listId: id of list where this is happening\n      if (action.payload.dragId === action.payload.swapId) {\n        return;\n      }\n      return state.map( list => {\n        \n        if (list.id === action.payload.listId) {\n          let dragIndex = list.items.indexOf(action.payload.dragId);\n          let swapIndex = list.items.indexOf(action.payload.swapId);\n          let sortedIndexes = [dragIndex, swapIndex].sort();\n          return {\n            ...list,\n            items: [\n              list.items.slice(0, sortedIndexes[0]),\n              list.items[sortedIndexes[0]],\n              list.items[sortedIndexes[1]],\n              list.items.slice(\n                sortedIndexes[1]+1,\n                list.items.length)\n            ],\n          }\n        } else {\n          return list\n        }\n      });\n    case 'REMOVE_TODO':\n      // payload:\n      //  - listId: id of list losing the todo\n      //  - itemId: id of the item being removed\n      //  : should check and make sure there's only one of\n      //     the specified id?\n      return state.map( list => {\n        if (list.id === action.payload.listId) {\n          let obj = list.items;\n          return {...list, items: obj.filter(\n            item => item !== action.payload.itemId),}\n        } else {\n          return list\n        }\n      });\n\n    default:\n      return state;\n  }\n};\n\nconst itemReducer = (state, action) => {\n  let obj = null;\n  switch(action.type) {\n    case 'ADD_TODO':\n      return {...state, [action.payload.id]: action.payload};\n    case 'REMOVE_TODO':\n      delete state[action.payload.itemId];\n      return state;\n    case 'UPDATE_TODO_CONTENT':\n      obj = state[action.payload.id];\n      return {...state, [action.payload.id]: {...obj, content: action.payload.content}};\n    case 'SWAP_TODO_INDEX':\n      // receives two item ids, swaps their index values\n      // payload: {\n      //    hoverIndex: integer index of hovered item\n      //    draggedIndex: integer index of dragged item\n      //    hoverId: integer ID of hovered item\n      //    draggedId: integer ID of dragged item\n      //    }\n      const draggedIndex = action.payload.draggedIndex;\n      return state.map( item => {\n        if (item.id === action.payload.draggedId) {\n          return {...item, index: action.payload.hoverIndex}\n        } else if (item.id === action.payload.hoverId) {\n          return {...item, index: draggedIndex}\n        } else {\n          return item;\n        }\n      });\n    case 'SET_IS_PLACEHOLDER':\n      obj = state[action.payload.itemId];\n      return {...state, [action.payload.itemId]: {...obj, isPlaceholder: action.payload.isPlaceholder}};\n    default:\n      return state;\n  }\n};\n\nconst dragReducer = (state, action) => {\n  switch(action.type) {\n    case 'SET_DRAGGED_ITEM':\n      return {...state, item: action.payload.item,\n        index: action.payload.index};\n    case 'CLEAR_DRAGGED_ITEM':\n      return {...state, item: null};\n    case 'UPDATE_HOVERED_LIST':\n      return {...state, list: action.payload};\n    case 'CLEAR_HOVERED_LIST':\n      return {...state, list: null}\n    default:\n      return state;\n    }\n};\n\nexport const ListDispatchContext = React.createContext(null);\nexport const ItemDispatchContext = React.createContext(null);\n\n// Data architecture:\n//  Three reducers:\n//  - listReducer: An array of JS Objects\n//      - id: Integer, unique within the application\n//      - title: String, title of the list\n//  - itemReducer: An array of item objects:\n//      - id: Integer, unique within the application\n//      - content: String, the actual todo-text input by user\n//      - index: order placement on the list\n//  - dragReducer: Object with info about current drag operation\n//      - item: Integer, id of currently dragged item\n//      - list: Integer, id of currently hovered list\n//       \n//  \n//  * Dragged item information is tracked outside of the \n//    built-in event.dataTransfer object, because the HTML5\n//    drag-and-drop spec does not allow dataTransfer to be\n//    accessed during a dragOver event. However, I need to \n//    know which item is being dragged over so I can update\n//    it's owning list, and index/order in the list, as the\n//    user drags the item around - allowing for visual \n//    feedback in the form of a placeholder/shadow item\n//    underneath the user's cursor.\n// \n//  There are a handful of properties that don't get stored\n//    in the reducer, for example whether a list can be \n//    deleted - this is hardcoded to off for the weekdays, and\n//    on for everything else. May change in the future.\n//\n//  Lists also receive their current number of items as a prop\n//    for passing through itemDispatch to set correct item \n//    order (new items are assigned index=listSize) \n//      -> no longer true since switch to arrays of items on lists\n//\n//  The board is constructed by referencing both reducers to\n//    get the lists and their items, pulling item content out\n//    of the item reducer along the way.\n\nconst initialListState = [\n  {id: 'm', title: \"Monday\", items: []},\n  {id: 't', title: \"Tuesday\", items: []},\n  {id: 'w', title: \"Wednesday\", items: []},\n  {id: 'r', title: \"Thursday\", items: []},\n  {id: 'f', title: \"Friday\", items: []},\n  {id: 's', title: \"Saturday\", items: []},\n  {id: 'u', title: \"Sunday\", items: []},\n];\n\nconst initialItemState = {};\nconst initialDragState = {};\n\nconst Todoboard = (props) => {\n  const [lists, listDispatch] = React.useReducer(listReducer, initialListState);\n  const [allItems, itemDispatch] = React.useReducer(itemReducer, initialItemState);\n  const [draggedItem, dragDispatch] = React.useReducer(dragReducer, initialDragState);\n\n  const [nextItemId, setNextItemId] = React.useState(props.startId || 0);\n\n  const getId = () => {\n    const outId = nextItemId;\n    setNextItemId(nextItemId + 1);\n    return outId;\n  };\n  \n  const newList = () => {\n    const outList = {\n      title: \"New List\",\n      id: getId(),\n      items: [],\n    };\n    return outList;\n  };\n\n  const addList = () => {\n    const nl = newList();\n    listDispatch({type: 'ADD_LIST', listId: nl.id, payload: nl});\n  };\n\n  const removeList = (listId) => {\n    // remove a lists items first to prevent orphaned data\n    // - remember items on lists are just id's!\n    lists.map( list => {\n      if (list.id === listId) {\n        list.items.forEach( item => {\n          itemDispatch({\n            type: 'REMOVE_TODO',\n            payload: {\n              itemId: item,\n            },\n          });\n        });\n      }\n      return list\n    });\n    listDispatch({type: 'REMOVE_LIST', listId: listId});\n  };\n\n  const getListSize = (listId) => {\n    return lists[listId].items.length;\n  };\n\n  const handleDragEnd = (event) => {\n    dragDispatch({\n      type: 'CLEAR_DRAGGED_ITEM',\n    });\n    dragDispatch({\n      type: 'CLEAR_HOVERED_LIST',\n    });\n  };\n\n  const handleDrop = (event) => {\n    event.preventDefault();\n    itemDispatch({\n      type: 'SET_IS_PLACEHOLDER',\n      payload: {\n        itemId: draggedItem.item, \n        isPlaceholder: false},\n    });\n    dragDispatch({\n      type: 'CLEAR_DRAGGED_ITEM',\n    });\n    dragDispatch({\n      type: 'CLEAR_HOVERED_LIST',\n    });\n  };\n\n  const AddListButton = () => {\n    return (\n      <button\n        className=\"addListButton\"\n        onClick={addList}\n      >{\"+ Add list\"}</button>\n    );\n  };\n\n  const ListContainer = (props) => {\n    return (\n      <div className={props.thisClass}>\n        <div className={`${props.thisClass}-container`}>\n          {props.children}\n        </div>\n      </div>\n    );\n  };\n\n  const onDragEnd = ({source, destination}) => {\n    if (source === null || destination === null) return;\n    listDispatch({\n      type: 'MOVE_TODO',\n      payload: {\n        sourceList: source.droppableId,\n        sourceIndex: source.index,\n        destList: destination.droppableId,\n        destIndex: destination.index,\n      }\n    });\n  };\n\n  return (\n    <>\n    <DragDropContext onDragEnd={onDragEnd}>\n    <ListDispatchContext.Provider value={listDispatch}>\n    <ItemDispatchContext.Provider value={itemDispatch}>\n    <ListContainer thisClass=\"calendar\">\n        {lists.map( (list, index) => (\n          (index <= 6) &&\n              <>\n              <Todolist\n                thisClass={\"calendar\"}\n                title={list.title}\n                key={list.id}\n                id={list.id}\n                ownedItems={list.items}\n                allItems={allItems}\n                getSize={getListSize}\n                getId={getId}\n                canDelete={false}\n                canEditTitle={false}\n                onDeleteClick={() => removeList(list.id)}\n              />\n              </>\n        ))}\n    </ListContainer>\n    <hr style={{width: \"90vw\"}}/>\n    <ListContainer thisClass=\"todo\">\n        {lists.length > 0 &&\n          <>\n          {lists.map( (list, index) => (\n            (index > 6) && \n            <>\n             <Todolist\n                thisClass={\"todo\"}\n                title={list.title}\n                key={list.id}\n                id={list.id}\n                ownedItems={list.items}\n                allItems={allItems}\n                getSize={getListSize}\n                getId={getId} \n                canDelete={true}\n                canEditTitle={true}\n                draggedItem={draggedItem}\n                dragDispatch={dragDispatch}\n              onDeleteClick={() => removeList(list.id)}\n             />\n            </>\n          ))}\n          </>\n        }\n        <AddListButton />\n    </ListContainer>\n    </ItemDispatchContext.Provider>\n    </ListDispatchContext.Provider>\n    </DragDropContext>\n    </>\n  )\n};\n\nexport default Todoboard;\n","import React from 'react';\nimport Todoboard from './Todoboard';\n\nimport './App.css';\n\nclass App extends React.Component {\n\n  render() {\n    return (\n        <div className=\"app\">\n          <Todoboard />\n        </div>\n    );\n  }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}